<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BonsaiDb User&#x27;s Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">About BonsaiDb</li><li class="chapter-item expanded "><a href="about/concepts.html"><strong aria-hidden="true">1.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="about/concepts/document.html"><strong aria-hidden="true">1.1.</strong> Document</a></li><li class="chapter-item expanded "><a href="about/concepts/collection.html"><strong aria-hidden="true">1.2.</strong> Collection</a></li><li class="chapter-item expanded "><a href="about/concepts/view.html"><strong aria-hidden="true">1.3.</strong> View</a></li><li class="chapter-item expanded "><a href="about/concepts/schema.html"><strong aria-hidden="true">1.4.</strong> Schema</a></li><li class="chapter-item expanded "><a href="about/concepts/database.html"><strong aria-hidden="true">1.5.</strong> Database</a></li><li class="chapter-item expanded "><a href="about/concepts/storage.html"><strong aria-hidden="true">1.6.</strong> Storage</a></li><li class="chapter-item expanded "><a href="about/concepts/pubsub.html"><strong aria-hidden="true">1.7.</strong> PubSub</a></li></ol></li><li class="chapter-item expanded "><a href="about/access_models.html"><strong aria-hidden="true">2.</strong> How can BonsaiDb be accessed?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="about/access-models/custom-api-server.html"><strong aria-hidden="true">2.1.</strong> Custom Api Server</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Integration</li><li class="chapter-item expanded "><a href="integration/overview.html"><strong aria-hidden="true">3.</strong> Overview</a></li><li class="chapter-item expanded "><a href="integration/local.html"><strong aria-hidden="true">4.</strong> Local</a></li><li class="chapter-item expanded "><a href="integration/server.html"><strong aria-hidden="true">5.</strong> Networked</a></li><li class="chapter-item expanded "><a href="integration/cluster.html"><strong aria-hidden="true">6.</strong> Clustered (upcoming)</a></li><li class="chapter-item expanded affix "><li class="part-title">Core Traits</li><li class="chapter-item expanded "><a href="traits/connection.html"><strong aria-hidden="true">7.</strong> Connection</a></li><li class="chapter-item expanded "><a href="traits/storage_connection.html"><strong aria-hidden="true">8.</strong> StorageConnection</a></li><li class="chapter-item expanded "><a href="traits/pubsub.html"><strong aria-hidden="true">9.</strong> PubSub</a></li><li class="chapter-item expanded "><a href="traits/key-value.html"><strong aria-hidden="true">10.</strong> KeyValue</a></li><li class="chapter-item expanded affix "><li class="part-title">Administration</li><li class="chapter-item expanded "><a href="administration/configuration.html"><strong aria-hidden="true">11.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="administration/permissions.html"><strong aria-hidden="true">12.</strong> Permissions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="administration/permission-statements.html"><strong aria-hidden="true">12.1.</strong> Permission Statements</a></li><li class="chapter-item expanded "><a href="administration/rbac.html"><strong aria-hidden="true">12.2.</strong> Users, Groups, and Roles</a></li></ol></li><li class="chapter-item expanded "><a href="administration/encryption.html"><strong aria-hidden="true">13.</strong> At-Rest Encryption</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">BonsaiDb User&#x27;s Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bonsaidb-users-guide"><a class="header" href="#bonsaidb-users-guide">BonsaiDb User's Guide</a></h1>
<p>BonsaiDb is an ACID-compliant, document-database written in Rust. Its goal is to be a general-purpose database that aims to simplify development and deployment by providing reliable building blocks that are lightweight enough for hobby projects running with minimal resources, but scalable for when your hobby project becomes a deployed product.</p>
<p>This user's guide aims to provide a guided walkthrough for users to understand how BonsaiDb works. This guide is meant to be supplemental <a href="https://dev.bonsaidb.io/main/bonsaidb/">to the documentation</a>. If you learn best by exploring examples, <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples">many are available in <code>/examples</code> in the repository</a>. If, however, you learn best by taking a guided tour of how something works, this guide is specifically for you.</p>
<p>If you have any feedback on this guide, please <a href="https://github.com/khonsulabs/bonsaidb/issues">file an issue</a>, and we will try to address any issues or shortcomings.</p>
<p>Thank you for exploring BonsaiDb.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>This is a list of common concepts that will be used throughout this book as well as the documentation.</p>
<ul>
<li><a href="about/./concepts/document.html">Document</a></li>
<li><a href="about/./concepts/collection.html">Collection</a></li>
<li><a href="about/./concepts/view.html">View</a></li>
<li><a href="about/./concepts/schema.html">Schema</a></li>
<li><a href="about/./concepts/database.html">Database</a></li>
<li><a href="about/./concepts/storage.html">Storage</a></li>
<li><a href="about/./concepts/pubsub.html">PubSub</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="document"><a class="header" href="#document">Document</a></h1>
<p>A <a href="https://dev.bonsaidb.io/main/bonsaidb/core/document/struct.Document.html">Document</a> is a single piece of stored data. Each document is stored within a <a href="about/concepts/./collection.html"><code>Collection</code></a>, and has a unique ID within that Collection.</p>
<p>When a Document is updated, BonsaiDb will check that the revision information passed matches the currently stored information. If not, a <a href="https://dev.bonsaidb.io/main/bonsaidb/core/enum.Error.html#variant.DocumentConflict">conflict error</a> will be returned. This simple check ensures that if two writers try to update the document simultaneously, one will succeed and the other will receive an error.</p>
<h2 id="serializable-collections"><a class="header" href="#serializable-collections">Serializable Collections</a></h2>
<p>BonsaiDb provides the <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.SerializedCollection.html"><code>SerializedCollection</code></a> trait, which allows automatic serialization and deserialization in many sitautions. When using <a href="https://dev.bonsaidb.io/main/bonsaidb/core/document/struct.Document.html#method.contents"><code>Document::contents()</code></a> function, the document is serialized and deserialized by the format returned from <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.SerializedCollection.html#tymethod.format"><code>SerializedCollection::format()</code></a>.</p>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/struct.CollectionDocument.html"><code>CollectionDocument</code></a> type provides convenience methods of interacting with serializable documents.</p>
<h3 id="default-serialization-of-serde-compatible-types"><a class="header" href="#default-serialization-of-serde-compatible-types">Default serialization of Serde-compatible types</a></h3>
<p>BonsaiDb provides a convenience trait for <a href="https://serde.rs/">Serde</a>-compatible data types: <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.DefaultSerialization.html"><code>DefaultSerialization</code></a>. This empty trait can be implemented on any collection to have BonsaiDb provide its preferred serialization format, <a href="https://github.com/khonsulabs/pot">Pot</a>.</p>
<h2 id="raw-collections"><a class="header" href="#raw-collections">Raw Collections</a></h2>
<p>If you would prefer to manually manage the data stored inside of a Document, you can directly manage the <a href="https://dev.bonsaidb.io/main/bonsaidb/core/document/struct.Document.html#structfield.contents"><code>contents</code></a> field. BonsaiDb will not interact with the <code>contents</code> of a Document. Only code that you write will parse or update the stored data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection"><a class="header" href="#collection">Collection</a></h1>
<p>A <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.Collection.html">Collection</a> is a group of <a href="about/concepts/./document.html">Documents</a> and associated functionality. The goal of a Collection is to encapsulate the logic for a set of data in such a way that Collections could be designed to be shared and reused in multiple <a href="about/concepts/./schema.html">Schemas</a> or applications.</p>
<p>Each Collection must have a unique <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/struct.CollectionName.html"><code>CollectionName</code></a>.</p>
<p>A Collection can contain one or more <a href="about/concepts/./view.html">Views</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view"><a class="header" href="#view">View</a></h1>
<p>A <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.View.html">View</a> is a <a href="https://en.wikipedia.org/wiki/MapReduce">map/reduce</a>-powered method of quickly accessing information inside of a <a href="about/concepts/./collection.html">Collection</a>. A View can only belong to one Collection.</p>
<p>Views define two important associated types: a Key type and a Value type. You can think of these as the equivalent entries in a map/dictionary-like collection that supports more than one entry for each Key. The Key is used to filter the View's results, and the Value is used by your application or the <code>reduce()</code> function.</p>
<p>Views are a powerful, yet abstract concept. Let's look at a concrete example: blog posts with categories.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Serialize, Deserialize, Debug)]
pub struct BlogPost {
    pub title: String,
    pub body: String,
    pub category: Option&lt;String&gt;,
}
</code></pre>
<p>While <code>category</code> should be an enum, let's first explore using <code>String</code> and upgrade to an enum at the end (it requires one additional step). Let's implement a View that will allow users to find blog posts by their category as well as count the number of posts in each category.</p>
<pre><code class="language-rust noplayground no_run">impl View for BlogPostsByCategory {
    type Collection = BlogPost;
    type Key = Option&lt;String&gt;;
    type Value = u32;

    fn name(&amp;self) -&gt; Result&lt;Name, InvalidNameError&gt; {
        Name::new(&quot;by-category&quot;)
    }
}

impl ViewSchema for BlogPostsByCategory {
    type View = Self;

    fn map(&amp;self, document: &amp;Document) -&gt; ViewMapResult&lt;Self::View&gt; {
        let post = document.contents::&lt;BlogPost&gt;()?;
        Ok(document.emit_key_and_value(post.category, 1))
    }

    fn reduce(
        &amp;self,
        mappings: &amp;[ViewMappedValue&lt;Self::View&gt;],
        _rereduce: bool,
    ) -&gt; ReduceResult&lt;Self::View&gt; {
        Ok(mappings.iter().map(|mapping| mapping.value).sum())
    }
}
</code></pre>
<p>The two traits being implemented are <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.View.html">View</a> and
<a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.ViewSchema.html">ViewSchema</a>. These traits are designed to allow keeping the
<code>View</code> implementation in a shared code library that is used by both client-side
and server-side code, while keeping the <code>ViewSchema</code> implementation in the
server executable only.</p>
<h2 id="views-for-serializedcollection"><a class="header" href="#views-for-serializedcollection">Views for <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.SerializedCollection.html"><code>SerializedCollection</code></a></a></h2>
<p>For users who are using <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.SerializedCollection.html"><code>SerializedCollection</code></a>, <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.CollectionViewSchema.html"><code>CollectionViewSchema</code></a> can be implemented instead of <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.ViewSchema.html"><code>ViewSchema</code></a>. The only difference between the two is that the <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.CollectionViewSchema.html#tymethod.map"><code>map()</code></a> function takes a <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/struct.CollectionDocument.html"><code>CollectionDocument</code></a> instead of a <a href="https://dev.bonsaidb.io/main/bonsaidb/core/document/struct.Document.html"><code>Document</code></a>.</p>
<h2 id="value-serialization"><a class="header" href="#value-serialization">Value Serialization</a></h2>
<p>For views to function, the Value type must able to be serialized and deserialized from storage. To accomplish this, all views must implement the <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.SerializedView.html"><code>SerializedView</code></a> trait. For <a href="https://serde.rs/">Serde</a>-compatible data structures, <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.DefaultViewSerialization.html"><code>DefaultSerializedView</code></a> is an empty trait that can be implemented instead to provide the default serialization that BonsaiDb recommends.</p>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<p>The first line of the <code>map</code> function calls <a href="https://dev.bonsaidb.io/main/bonsaidb/core/document/struct.Document.html#method.contents"><code>Document::contents()</code></a> to deserialize the stored <code>BlogPost</code>. The second line returns an emitted Key and Value -- in our case a clone of the post's category and the value <code>1_u32</code>. With the map function, we're able to use <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/struct.View.html#method.query"><code>query()</code></a> and <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/struct.View.html#method.query_with_docs"><code>query_with_docs()</code></a>:</p>
<pre><code class="language-rust noplayground no_run">    let rust_posts = db
        .view::&lt;BlogPostsByCategory&gt;()
        .with_key(Some(String::from(&quot;Rust&quot;)))
        .query_with_docs()
        .await?;
</code></pre>
<p>The above queries the <a href="about/concepts/./database.html">Database</a> for all documents in the <code>BlogPost</code> Collection that emitted a Key of <code>Some(&quot;Rust&quot;)</code>.</p>
<h2 id="reduce"><a class="header" href="#reduce">Reduce</a></h2>
<p>The second function to learn about is the <code>reduce()</code> function. It is responsible for turning an array of Key/Value pairs into a single Value. In some cases, BonsaiDb might need to call <code>reduce()</code> with values that have already been reduced one time. If this is the case, <code>rereduce</code> is set to true.</p>
<p>In this example, we're using the built-in <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum"><code>Iterator::sum()</code></a> function to turn our Value of <code>1_u32</code> into a single <code>u32</code> representing the total number of documents.</p>
<pre><code class="language-rust noplayground no_run">    let rust_post_count = db
        .view::&lt;BlogPostsByCategory&gt;()
        .with_key(Some(String::from(&quot;Rust&quot;)))
        .reduce()
        .await?;
</code></pre>
<h2 id="changing-an-exising-view"><a class="header" href="#changing-an-exising-view">Changing an exising view</a></h2>
<p>If you have data stored in a view, but want to update the view to store data
differently, implement <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.ViewSchema.html#method.version"><code>ViewSchema::version()</code></a> and return
a unique number. When BonsaiDb checks the view's integrity, it will notice that
there is a version mis-match and automatically re-index the view.</p>
<p>There is no mechanism to access the data until this operation is complete.</p>
<h3 id="understanding-re-reduce"><a class="header" href="#understanding-re-reduce">Understanding Re-reduce</a></h3>
<p>Let's examine this data set:</p>
<table><thead><tr><th>Document ID</th><th>BlogPost Category</th></tr></thead><tbody>
<tr><td>1</td><td>Some(&quot;Rust&quot;)</td></tr>
<tr><td>2</td><td>Some(&quot;Rust&quot;)</td></tr>
<tr><td>3</td><td>Some(&quot;Cooking&quot;)</td></tr>
<tr><td>4</td><td>None</td></tr>
</tbody></table>
<p>When updating views, each view entry is reduced and the value is cached. These
are the view entries:</p>
<table><thead><tr><th>View Entry ID</th><th>Reduced Value</th></tr></thead><tbody>
<tr><td>Some(&quot;Rust&quot;)</td><td>2</td></tr>
<tr><td>Some(&quot;Cooking&quot;)</td><td>1</td></tr>
<tr><td>None</td><td>1</td></tr>
</tbody></table>
<p>When a reduce query is issued for a single key, the value can be returned without further processing. But, if the reduce query matches multiple keys, the View's <code>reduce()</code> function will be called with the already reduced values with <code>rereduce</code> set to <code>true</code>. For example, retrieving the total count of blog posts:</p>
<pre><code class="language-rust noplayground no_run">    let total_post_count = db.view::&lt;BlogPostsByCategory&gt;().reduce().await?;
</code></pre>
<p>Once BonsaiDb has gathered each of the key's reduced values, it needs to further reduce that list into a single value. To accomplish this, the View's <code>reduce()</code> function to be invoked with <code>rereduce</code> set to <code>true</code>, and with mappings containing:</p>
<table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td>Some(&quot;Rust&quot;)</td><td>2</td></tr>
<tr><td>Some(&quot;Cooking&quot;)</td><td>1</td></tr>
<tr><td>None</td><td>1</td></tr>
</tbody></table>
<p>This produces a final value of 4.</p>
<h2 id="how-does-bonsaidb-make-this-efficient"><a class="header" href="#how-does-bonsaidb-make-this-efficient">How does BonsaiDb make this efficient?</a></h2>
<p>When saving Documents, BonsaiDb does not immediately update related views. It instead notes what documents have been updated since the last time the View was indexed.</p>
<p>When a View is accessed, the queries include an <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/enum.AccessPolicy.html"><code>AccessPolicy</code></a>. If you aren't overriding it, <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/enum.AccessPolicy.html#variant.UpdateBefore"><code>UpdateBefore</code></a> is used. This means that when the query is evaluated, BonsaiDb will first check if the index is out of date due to any updated data. If it is, it will update the View before evaluating the query.</p>
<p>If you're wanting to get results quickly and are willing to accept data that might not be updated, the access policies <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/enum.AccessPolicy.html#variant.UpdateAfter"><code>UpdateAfter</code></a> and <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/enum.AccessPolicy.html#variant.NoUpdate"><code>NoUpdate</code></a> can be used depending on your needs.</p>
<p>If multiple simulataneous queries are being evaluted for the same View and the View is outdated, BonsaiDb ensures that only a single view indexer will execute while both queries wait for it to complete.</p>
<h2 id="using-arbitrary-types-as-a-view-key"><a class="header" href="#using-arbitrary-types-as-a-view-key">Using arbitrary types as a View Key</a></h2>
<p>In our previous example, we used <code>String</code> for the Key type. The reason is important: Keys must be sortable by <a href="http://sled.rs/">our underlying storage engine</a>, which means special care must be taken. Most serialization types do not guarantee binary sort order. Instead, BonsaiDb exposes the <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.Key.html"><code>Key</code></a> trait. On that documentation page, you can see that BonsaiDb implements <code>Key</code> for many built-in types.</p>
<h3 id="using-an-enum-as-a-view-key"><a class="header" href="#using-an-enum-as-a-view-key">Using an enum as a View Key</a></h3>
<p>The easiest way to expose an enum is to derive <a href="https://docs.rs/num-traits/0.2.14/num_traits/cast/trait.FromPrimitive.html"><code>num_traits::FromPrimitive</code></a> and <a href="https://docs.rs/num-traits/0.2.14/num_traits/cast/trait.ToPrimitive.html"><code>num_traits::ToPrimitive</code></a> using <a href="https://crates.io/crates/num-derive">num-derive</a>, and add an <code>impl EnumKey</code> line:</p>
<pre><code class="language-rust noplayground no_run">#[derive(
    Serialize, Deserialize, Debug, num_derive::FromPrimitive, num_derive::ToPrimitive, Clone,
)]
pub enum Category {
    Rust,
    Cooking,
}

impl EnumKey for Category {}
</code></pre>
<p>The View code remains unchanged, although the associated Key type can now be set to <code>Option&lt;Category&gt;</code>. The queries can now use the enum instead of a <code>String</code>:</p>
<pre><code class="language-rust noplayground no_run">    let rust_post_count = db
        .view::&lt;BlogPostsByCategory&gt;()
        .with_key(Some(Category::Rust))
        .reduce()
        .await?;
</code></pre>
<p>BonsaiDb will convert the enum to a u64 and use that value as the Key. A u64 was chosen to ensure fairly wide compatibility even with some extreme usages of bitmasks. If you wish to customize this behavior, you can implement <code>Key</code> directly.</p>
<h3 id="implementing-the-key-trait"><a class="header" href="#implementing-the-key-trait">Implementing the <code>Key</code> trait</a></h3>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.Key.html"><code>Key</code></a> trait declares two functions: <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.Key.html#tymethod.as_big_endian_bytes"><code>as_big_endian_bytes()</code></a> and <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.Key.html#tymethod.from_big_endian_bytes"><code>from_big_endian_bytes</code></a>. The intention is to convert the type to bytes using a network byte order for numerical types, and for non-numerical types, the bytes need to be stored in binary-sortable order.</p>
<p>Here is how BonsaiDb implements Key for <code>EnumKey</code>:</p>
<pre><code class="language-rust noplayground no_run">impl&lt;T&gt; Key for T
where
    T: EnumKey,
{
    type Error = std::io::Error;
    const LENGTH: Option&lt;usize&gt; = None;

    fn as_big_endian_bytes(&amp;self) -&gt; Result&lt;Cow&lt;'_, [u8]&gt;, Self::Error&gt; {
        let integer = self
            .to_u64()
            .map(Unsigned::from)
            .ok_or_else(|| std::io::Error::new(ErrorKind::InvalidData, IncorrectByteLength))?;
        Ok(Cow::Owned(integer.to_variable_vec()?))
    }

    fn from_big_endian_bytes(bytes: &amp;[u8]) -&gt; Result&lt;Self, Self::Error&gt; {
        let primitive = u64::decode_variable(bytes)?;
        Self::from_u64(primitive)
            .ok_or_else(|| std::io::Error::new(ErrorKind::InvalidData, UnknownEnumVariant))
    }
}
</code></pre>
<p>By implementing <code>Key</code> you can take full control of converting your view keys.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema"><a class="header" href="#schema">Schema</a></h1>
<p>A <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.Schema.html">Schema</a> is a group of one or more <a href="about/concepts/./collection.html">Collections</a>. A Schema can be instantiated as a <a href="about/concepts/./database.html">Database</a>. The Schema describes how a set of data behaves, and a Database is a set of data on-disk.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database"><a class="header" href="#database">Database</a></h1>
<p>A Database is a set of stored data. Each Database is described by a <a href="about/concepts/./schema.html">Schema</a>. Unlike the other concepts, this concept corresponds to multiple types:</p>
<ul>
<li>For bonsaidb-local: <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Database.html"><code>Database</code></a></li>
<li>For bonsaidb-server: <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerDatabase.html"><code>ServerDatabase</code></a></li>
<li>For bonsaidb-client: <a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a></li>
</ul>
<p>All of these types implement the <a href="about/concepts/../../traits/connection.html"><code>Connection</code></a> trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/trait.StorageConnection.html">StorageConnection</a> trait allows interacting with a BonsaiDb multi-database storage instance.</p>
<p>There are three implementations of the <code>StorageConnection</code> trait:</p>
<ul>
<li><a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Storage.html"><code>Storage</code></a>: A local, file-based server implementation with no networking capabilities.</li>
<li><a href="https://dev.bonsaidb.io/main/bonsaidb/server/type.Server.html"><code>Server</code></a>: A networked server implementation, written using <code>Storage</code>. This server supports <a href="https://en.wikipedia.org/wiki/QUIC">QUIC</a>- and <a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a>-based protocols. The QUIC protocol is preferred, but it uses UDP which many load balancers don't support. If you're exposing <code>BonsaiDb</code> behind a load balancer, WebSockets may be the only option depending on your host's capabilities.</li>
<li><a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.Client.html"><code>Client</code></a>: A network client implementation that connects to a <code>Server</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubsub"><a class="header" href="#pubsub">PubSub</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Publish/Subscribe pattern</a> enables developers to design systems that produce and receive messages. It is implemented for BonsaiDb through the <a href="about/concepts/../../traits/pubsub.html"><code>PubSub</code> and <code>Subscriber</code></a> traits.</p>
<p>A common example of what PubSub enables is implementing a simple chat system. Each chat participant can subscribe to messages on the <code>chat</code> topic, and when any participant publishes a <code>chat</code> message, all subscribers will receive a copy of that message.</p>
<p>A working example of PubSub is available at <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/pubsub.rs"><code>examples/basic-local/examples/pubsub.rs</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-cases-of-bonsaidb"><a class="header" href="#use-cases-of-bonsaidb">Use cases of BonsaiDb</a></h1>
<h2 id="single-database-model-no-networking"><a class="header" href="#single-database-model-no-networking">Single database model (No networking)</a></h2>
<p>This use case is most similar to utilizing SQLite for your database. In this mode, BonsaiDb directly interacts with files on your disk to provide your database. Unlike other file-based databases, however, it's easy to migrate to any of these scenarios from this starting position:</p>
<pre class="mermaid">graph LR
  code{{Rust Code}}
  local[(bonsaidb-local::Database)]
  code &lt;--&gt; local
</pre>
<p>A working example of how to use a local database can be found at <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/basic-local.rs"><code>examples/basic-local/examples/basic-local.rs</code></a>.</p>
<h2 id="multi-database-model-no-networking"><a class="header" href="#multi-database-model-no-networking">Multi-database model (No networking)</a></h2>
<p>This model is most similar to using multiple SQLite databases. In this mode, you interact with a <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Storage.html"><code>Storage</code></a> that you spawn within your code.</p>
<pre class="mermaid">graph LR
  code{{Rust Code}}
  local[(bonsaidb-local::Storage)]
  code &lt;--&gt; server
  server &lt;--&gt; local
</pre>
<p>If you look at the source behind <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Storage.html#method.open_local"><code>Database::open_local</code></a>, you'll see that the single-database model is using <code>Storage</code> under the hood.</p>
<h2 id="server-model-quic-or-websockets"><a class="header" href="#server-model-quic-or-websockets">Server model (QUIC or WebSockets)</a></h2>
<p>This model is most similar to using other document databases, like CouchDB or MongoDB. In this mode, you interact with a <a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.Client.html"><code>Client</code></a> that connects via either QUIC or WebSockets with a server. From the server code's perspective, this model is the same as the multi-database model, except that the server is listening for and responding to network traffic.</p>
<pre class="mermaid">graph LR
  client-code{{Rust Client Code}}
  server-code{{Rust Server Code}}
  client[[bonsaidb-client]]
  server[[bonsaidb-server]]
  local[(bonsaidb-local)]
  client-code &lt;--&gt; client
  client &lt;-. network .-&gt; server
  server &lt;--&gt; local
  server-code &lt;--&gt; server
</pre>
<p>A working example of this model can be found at <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-server/examples/basic-server.rs"><code>examples/basic-server/examples/basic-server.rs</code></a>. When writing client/server applications that utilize <code>BonsaiDb</code>, you can have the <code>BonsaiDb</code> server running withing your server application. This means that your server still has the ability not use networking to interact with <code>BonsaiDb</code>. Regardless of if you run any other server code, your <code>BonsaiDb</code> server will be accessible through a <code>Client</code> over the network.</p>
<h2 id="api-platform-model-quic-or-websockets"><a class="header" href="#api-platform-model-quic-or-websockets">API Platform model (QUIC or WebSockets)</a></h2>
<p>If you're finding yourself developing an API for your application, and all of the consumers of this API are already connected to <code>BonsaiDb</code>, you may want to take advantage of the custom api functionality of the server:</p>
<pre class="mermaid">graph LR
  client-code{{Rust Client Code}}
  server-code{{Rust Server Code}}
  client[[bonsaidb-client]]
  server[[bonsaidb-server]]
  backend[[Backend]]
  local[(bonsaidb-local)]
  client-code &lt;--&gt; client
  client &lt;-. network .-&gt; server
  server &lt;--&gt; local
  server-code &lt;--&gt; server
  server-code &lt;--&gt; backend
  backend &lt;--&gt; server
</pre>
<p>The <code>BonsaiDb</code> <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.CustomServer.html"><code>CustomServer</code></a> type accepts one generic parameter that implements the <a href="https://dev.bonsaidb.io/main/bonsaidb/server/trait.Backend.html"><code>Backend</code></a> trait. This trait is used to customize the server in many ways, but one of the associated types is a <a href="https://dev.bonsaidb.io/main/bonsaidb/core/custom_api/trait.CustomApi.html"><code>CustomApi</code></a> implementor.</p>
<p>See <a href="about/./access-models/custom-api-server.html">this page</a> for an overview of how to set up a custom api server.</p>
<h2 id="coming-later-cluster-model"><a class="header" href="#coming-later-cluster-model">Coming Later: Cluster model</a></h2>
<p>When you're at the stage of scaling beyond a single server, you will be able to upgrade your server to a cluster using the hypothetical <code>bonsaidb-cluster</code> crate. The clustering model is still being designed, but the goal is something similar to:</p>
<pre class="mermaid">graph LR
  client-code{{Rust Client Code}}
  server-code{{Rust Server Code}}
  client[[bonsaidb-client]]
  server1[[server 1]]
  server2[[server 2]]
  server3[[server 3]]
  cluster[[bonsaidb-cluster]]
  client-code &lt;--&gt; client
  client &lt;-. network .-&gt; cluster
  server-code &lt;--&gt; cluster
  cluster &lt;--&gt; server1
  cluster &lt;--&gt; server2
  cluster &lt;--&gt; server3
  server1 &lt;--&gt; server2
  server2 &lt;--&gt; server3
  server1 &lt;--&gt; server3
</pre>
<p>In this model, the local storage element is hidden; Each server has its own storage. This model is very similar from the viewpoint of your server and client code -- the primary difference is that the server-side connection is being established using the cluster crate. From the client's perspective, the cluster behaves as a single entity -- sending a request to any server node will result in the same result within the cluster.</p>
<p>All features of BonsaiDb will be designed to work in cluster mode seamlessly. <code>PubSub</code> will ensure that subscribers will receive messages regardless of which server they're connected to.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-api-server"><a class="header" href="#custom-api-server">Custom Api Server</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/core/custom_api/trait.CustomApi.html"><code>CustomApi</code></a> trait defines three associated types, Request, Response, and Error. A backend &quot;dispatches&quot; <code>Request</code>s and expects a <code>Result&lt;Response, Error&gt;</code> in return.</p>
<blockquote>
<p>All code on this page comes from this example: <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-server/examples/custom-api.rs"><code>examples/basic-server/examples/custom-api.rs</code></a>.</p>
</blockquote>
<p>This example defines a Request and a Response type, but uses <code>BonsaiDb</code>'s <a href="https://dev.bonsaidb.io/main/bonsaidb/core/custom_api/enum.Infallible.html"><code>Infallible</code></a> type for the error:</p>
<pre><code class="language-rust noplayground no_run">#[derive(Serialize, Deserialize, Actionable, Debug)]
#[actionable(actionable = bonsaidb::core::actionable)]
pub enum Request {
    #[actionable(protection = &quot;none&quot;)]
    Ping,
    #[actionable(protection = &quot;simple&quot;)]
    DoSomethingSimple { some_argument: u32 },
    #[actionable(protection = &quot;custom&quot;)]
    DoSomethingCustom { some_argument: u32 },
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum Response {
    Pong,
    DidSomething,
}

impl CustomApi for ExampleApi {
    type Request = Request;
    type Response = Response;
    type Error = Infallible;
}
</code></pre>
<p>To implement the server, we must first implement a custom <a href="https://dev.bonsaidb.io/main/bonsaidb/server/trait.Backend.html"><code>Backend</code></a> that ties the server to the <code>CustomApi</code>. We also must define a <a href="https://dev.bonsaidb.io/main/bonsaidb/server/trait.CustomApiDispatcher.html"><code>CustomApiDispatcher</code></a>, which gives an opportunity for the dispatcher to gain access to the <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ConnectedClient.html"><code>ConnectedClient</code></a> and/or <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.CustomServer.html">`CustomServer</a> instances if they are needed to handle requests.</p>
<p>Finally, either <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/trait.Dispatcher.html"><code>Dispatcher</code></a> must be implemented manually or <a href="https://dev.bonsaidb.io/main/bonsaidb/core/actionable/"><code>actionable</code></a> can be used to derive an implementation that uses individual traits to handle each request. The example uses actionable:</p>
<pre><code class="language-rust noplayground no_run">impl Backend for ExampleBackend {
    type CustomApi = ExampleApi;
    type CustomApiDispatcher = ExampleDispatcher;
    type ClientData = ();
}

/// Dispatches Requests and returns Responses.
#[derive(Debug, Dispatcher)]
#[dispatcher(input = Request, actionable = bonsaidb::core::actionable)]
pub struct ExampleDispatcher {
    // While this example doesn't use the server reference, this is how a custom
    // API can gain access to the running server to perform database operations
    // within the handlers. The `ConnectedClient` can also be cloned and stored
    // in the dispatcher if handlers need to interact with clients outside of a
    // simple Request/Response exchange.
    _server: CustomServer&lt;ExampleBackend&gt;,
}

impl CustomApiDispatcher&lt;ExampleBackend&gt; for ExampleDispatcher {
    fn new(
        server: &amp;CustomServer&lt;ExampleBackend&gt;,
        _client: &amp;ConnectedClient&lt;ExampleBackend&gt;,
    ) -&gt; Self {
        Self {
            _server: server.clone(),
        }
    }
}

#[async_trait]
impl RequestDispatcher for ExampleDispatcher {
    type Output = Response;
    type Error = BackendError&lt;Infallible&gt;;
}

/// The Request::Ping variant has `#[actionable(protection = &quot;none&quot;)]`, which
/// causes `PingHandler` to be generated with a single method and no implicit
/// permission handling.
#[async_trait]
impl PingHandler for ExampleDispatcher {
    async fn handle(
        &amp;self,
        _permissions: &amp;Permissions,
    ) -&gt; Result&lt;Response, BackendError&lt;Infallible&gt;&gt; {
        Ok(Response::Pong)
    }
}
</code></pre>
<p>Finally, the client can issue the API call and receive the response, without needing any extra steps to serialize. This works regardless of whether the client is connected via QUIC or WebSockets.</p>
<pre><code class="language-rust noplayground no_run">async fn ping_the_server(
    client: &amp;Client&lt;ExampleApi&gt;,
    client_name: &amp;str,
) -&gt; Result&lt;(), bonsaidb::core::Error&gt; {
    match client.send_api_request(Request::Ping).await {
        Ok(Response::Pong) =&gt; {
            println!(&quot;Received Pong from server on {}&quot;, client_name);
        }
        other =&gt; println!(
            &quot;Unexpected response from API call on {}: {:?}&quot;,
            client_name, other
        ),
    }

    Ok(())
}
</code></pre>
<h2 id="permissions"><a class="header" href="#permissions">Permissions</a></h2>
<p>One of the strengths of using BonsaiDb's custom api functionality is the ability to tap into the permissions handling that BonsaiDb uses. The Ping request was defined with <code>protection = &quot;none&quot;</code> which skips all permission validation. However, <code>DoSomethingSimple</code> uses the &quot;simple&quot; protection model, and <code>DoSomethingCustom</code> uses the &quot;custom&quot; protection model. The comments in the example below should help explain the rationale:</p>
<pre><code class="language-rust noplayground no_run">/// The permissible actions that can be granted for this example api.
#[derive(Debug, Action)]
#[action(actionable = bonsaidb::core::actionable)]
pub enum ExampleActions {
    DoSomethingSimple,
    DoSomethingCustom,
}

/// With `protection = &quot;simple&quot;`, `actionable` will generate a trait that allows
/// you to return a `ResourceName` and an `Action`, and the handler will
/// automatically confirm that the connected user has been granted the ability
/// to perform `Action` against `ResourceName`.
#[async_trait]
impl DoSomethingSimpleHandler for ExampleDispatcher {
    type Action = ExampleActions;

    async fn resource_name&lt;'a&gt;(
        &amp;'a self,
        _some_argument: &amp;'a u32,
    ) -&gt; Result&lt;ResourceName&lt;'a&gt;, BackendError&lt;Infallible&gt;&gt; {
        Ok(ResourceName::named(&quot;example&quot;))
    }

    fn action() -&gt; Self::Action {
        ExampleActions::DoSomethingSimple
    }

    async fn handle_protected(
        &amp;self,
        _permissions: &amp;Permissions,
        _some_argument: u32,
    ) -&gt; Result&lt;Response, BackendError&lt;Infallible&gt;&gt; {
        // The permissions have already been checked.
        Ok(Response::DidSomething)
    }
}

/// With `protection = &quot;custom&quot;`, `actionable` will generate a trait with two
/// functions: one to verify the permissions are valid, and one to do the
/// protected action. This is useful if there are multiple actions or resource
/// names that need to be checked, or if permissions change based on the
/// arguments passed.
#[async_trait]
impl DoSomethingCustomHandler for ExampleDispatcher {
    async fn verify_permissions(
        &amp;self,
        permissions: &amp;Permissions,
        some_argument: &amp;u32,
    ) -&gt; Result&lt;(), BackendError&lt;Infallible&gt;&gt; {
        if *some_argument == 42 {
            Ok(())
        } else {
            permissions.check(
                ResourceName::named(&quot;example&quot;),
                &amp;ExampleActions::DoSomethingCustom,
            )?;

            Ok(())
        }
    }

    async fn handle_protected(
        &amp;self,
        _permissions: &amp;Permissions,
        _some_argument: u32,
    ) -&gt; Result&lt;Response, BackendError&lt;Infallible&gt;&gt; {
        // `verify_permissions` has already been executed, so no permissions
        // logic needs to live here.
        Ok(Response::DidSomething)
    }
}
</code></pre>
<p>This example uses <code>authenticated_permissions</code> to grant access to <code>ExampleAction::DoSomethingSimple</code> and <code>ExampleAction::DoSomethingCustom</code> to all users who have logged in:</p>
<pre><code class="language-rust noplayground no_run">    let server = CustomServer::&lt;ExampleBackend&gt;::open(
        ServerConfiguration::new(&quot;server-data.bonsaidb&quot;)
            .default_permissions(Permissions::from(vec![Statement {
                resources: vec![ResourceName::any()],
                actions: ActionNameList::List(vec![
                    BonsaiAction::Server(ServerAction::Connect).name(),
                    BonsaiAction::Server(ServerAction::LoginWithPassword).name(),
                ]),
            }]))
            .authenticated_permissions(Permissions::from(vec![Statement {
                resources: vec![ResourceName::any()],
                actions: ActionNameList::List(vec![
                    ExampleActions::DoSomethingSimple.name(),
                    ExampleActions::DoSomethingCustom.name(),
                ]),
            }])),
    )
    .await?;
</code></pre>
<p>For more information on managing permissions, <a href="about/access-models/../../administration/permissions.html">see Administration/Permissions</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p><code>BonsaiDb</code> aims to offer the majority of its functionality in <a href="integration/./local.html">local operation</a>. The <a href="integration/./server.html">networked server</a> adds some functionality on top of the local version, but its main function is to add the ability to use networking to talk to the database.</p>
<p>Because of this model, it makes it easy to transition a local database to a networked database server. Start with whatever model fits your needs today, and when your neeeds change, <code>BonsaiDb</code> will adapt.</p>
<h2 id="when-to-use-the-local-integration"><a class="header" href="#when-to-use-the-local-integration">When to use the <a href="integration/./local.html">Local Integration</a></a></h2>
<ul>
<li>You're going to databases from one process at a time. <code>BonsaiDb</code> is designed for concurrency and can scale with the capabilities of the hardware. However, the underlying storage layer that <code>BonsaiDb</code> is built upon, <a href="http://sled.rs">sled</a>, does not support multiple processes writing its data simultaneously. If you need to access the database from multiple processes, the <a href="integration/./server.html">server integration</a> is what you should use. While it doesn't offer IPC communication today, a pull-request would be accepted to that added that functionality (along with the corresponding unit tests).</li>
<li>You have no public API/PubSub/access needs or have implemented those with another stack.</li>
</ul>
<h2 id="when-to-use-the-server-integration"><a class="header" href="#when-to-use-the-server-integration">When to use the <a href="integration/./server.html">Server Integration</a></a></h2>
<ul>
<li>You need to access databases from more than one process or machine.</li>
<li>You are OK with downtime due to loss of service when the single server is offline. If you need to have a <a href="https://en.wikipedia.org/wiki/High_availability">highly-available</a> database, you should use the Cluster Integration (Coming Soon).</li>
<li>Your database load can be met with a single machine. If you have enough load that you need to share the processing power of multiple servers, you should use the Cluster Integration (Coming Soon)</li>
</ul>
<h2 id="coming-soon-when-to-use-the-cluster-integration"><a class="header" href="#coming-soon-when-to-use-the-cluster-integration">Coming Soon: When to use the <a href="integration/./cluster.html">Cluster Integration</a></a></h2>
<ul>
<li>You need to access databases from more than one machine.</li>
<li>You need a <a href="https://en.wikipedia.org/wiki/High_availability">highly-available</a> setup.</li>
<li>You need/want to split load between multiple machines.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-bonsaidb-locally"><a class="header" href="#integrating-bonsaidb-locally">Integrating BonsaiDb Locally</a></h1>
<p><code>BonsaiDb</code> supports multiple <a href="integration/../about/concepts/database.html">databases</a> and multiple <a href="integration/../about/concepts/schema.html">schemas</a>. However, for many applications, you only need a single database.</p>
<p>If you're only wanting a single database, the setup is straightforward: (from <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/basic-local.rs"><code>examples/basic-local/examples/basic-local.rs</code></a>)</p>
<pre><code class="language-rust noplayground no_run">let db = Database::&lt;Message&gt;::open(
    StorageConfiguration::new(&quot;basic.bonsaidb&quot;)
).await?;
</code></pre>
<p>Under the hood, <code>BonsaiDb</code> is creating a multi-database <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Storage.html"><code>Storage</code></a> with a local <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Database.html"><code>Database</code></a> named <code>default</code> for you. If you need to switch to a multi-database model, you can open the storage and access the <code>default</code> database: (adapted from <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/basic-local-multidb.rs"><code>examples/basic-local/examples/basic-local.rs</code></a>)</p>
<pre><code class="language-rust noplayground no_run">let storage = Storage::open(
    Configuration::new(&quot;basic.bonsaidb&quot;)
        .with_schema::&lt;Message&gt;()?
).await?;
let db = storage.database::&lt;Message&gt;(&quot;default&quot;).await?;
</code></pre>
<p>You can register multiple schemas so that databases can be purpose-built.</p>
<h2 id="common-traits"><a class="header" href="#common-traits">Common Traits</a></h2>
<p>To help your code transition between different modes of accessing <code>BonsaiDb</code>, you can use these common traits to make your methods accept any style of <code>BonsaiDb</code> access.</p>
<ul>
<li><a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Database.html"><code>Database</code></a> implements <a href="integration/../traits/connection.html"><code>Connection</code></a>, <a href="integration/../traits/key-value.html"><code>KeyValue</code></a>, and <a href="integration/../traits/pubsub.html"><code>PubSub</code></a>.</li>
<li><a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Storage.html"><code>Storage</code></a> implements <a href="integration/../traits/storage_connection.html"><code>StorageConnection</code></a>.</li>
</ul>
<p>For example, <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-local/examples/basic-local-multidb.rs"><code>examples/basic-local/examples/basic-local.rs</code></a> uses this helper method to insert a record:</p>
<pre><code class="language-rust noplayground no_run">async fn insert_a_message&lt;C: Connection&gt;(
    connection: &amp;C,
    value: &amp;str,
) -&gt; Result&lt;(), bonsaidb::core::Error&gt; {
    Message {
        contents: String::from(value),
        timestamp: SystemTime::now(),
    }
    .push_into(connection)
    .await?;
    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-the-networked-bonsaidb-server"><a class="header" href="#integrating-the-networked-bonsaidb-server">Integrating the networked BonsaiDb Server</a></h1>
<p>To access <code>BonsaiDb</code> over the network, you're going to be writing two pieces of code: the server code and the client code.</p>
<h2 id="your-bonsaidb-server"><a class="header" href="#your-bonsaidb-server">Your BonsaiDb Server</a></h2>
<p>The first step is to create a <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Storage.html"><code>Server</code></a>, which uses local <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Storage.html"><code>Storage</code></a> under the hood. This means that if you're already using <code>BonsaiDb</code> in local mode, you can swap your usage of <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Storage.html"><code>Storage</code></a> with <a href="https://dev.bonsaidb.io/main/bonsaidb/server/type.Server.html"><code>Server</code></a> in your server code without running your database through any tools. Here's the setup code from <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-server/examples/basic-server.rs"><code>basic-server/examples/basic-server.rs</code></a></p>
<pre><code class="language-rust noplayground no_run">    let server = Server::open(
        ServerConfiguration::new(&quot;server-data.bonsaidb&quot;)
            .default_permissions(DefaultPermissions::AllowAll)
            .with_schema::&lt;Shape&gt;()?,
    )
    .await?;
    if server.certificate_chain().await.is_err() {
        server.install_self_signed_certificate(true).await?;
    }
    let certificate = server
        .certificate_chain()
        .await?
        .into_end_entity_certificate();
    server.create_database::&lt;Shape&gt;(&quot;my-database&quot;, true).await?;
</code></pre>
<p>Once you have a server initialized, calling <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.CustomServer.html#method.listen_on"><code>listen_on</code></a> will begin listening for connections on the port specified. This uses the preferred native protocol which uses UDP. If you find that UDP is not working for your setup or want to put <code>BonsaiDb</code> behind a load balancer that doesn't support UDP, you can enable WebSocket support and call <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.CustomServer.html#method.listen_for_websockets_on"><code>listen_for_websockets_on</code></a>.</p>
<p>You can call both, but since these functions don't return until the server is shut down, you should spawn them instead:</p>
<pre><code class="language-rust noplayground no_run">let task_server = server.clone();
tokio::spawn(async move {
    task_server.listen_on(5645).await
});
let server = server.clone();
tokio::spawn(async move {
    task_server.listen_for_websockets_on(&quot;localhost:8080&quot;, false).await
});
</code></pre>
<p>If you're not running any of your own code on the server, and you're only using one listening method, you can just await the listen method of your choice in your server's main. This code example configures BonsaiDb on UDP port 5645, but this is not <a href="https://github.com/khonsulabs/bonsaidb/issues/48">an officially registered port</a>.</p>
<!-- TODO: Certificates -->
<h2 id="from-the-client"><a class="header" href="#from-the-client">From the Client</a></h2>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.Client.html"><code>Client</code></a> can support both the native protocol and WebSockets. It determines which protocol to use based on the scheme in the URL:</p>
<ul>
<li><code>bonsaidb://host:port</code> will connect using the native <code>BonsaiDb</code> protocol.</li>
<li><code>ws://host:port</code> will connect using WebSockets.</li>
</ul>
<p>Here's how to connect, from <a href="https://github.com/khonsulabs/bonsaidb/blob/main/examples/basic-server/examples/basic-server.rs"><code>examples/basic-server/examples/basic-server.rs</code></a>:</p>
<pre><code class="language-rust noplayground no_run">Client::new(
    Url::parse(&quot;bonsaidb://localhost:5645&quot;)?,
    Some(certificate),
)
.await?
</code></pre>
<p>This is using a pinned certificate to connect. Other methods are supported, but better certificate management is coming soon.</p>
<!-- TODO: Certificates -->
<h2 id="common-traits-1"><a class="header" href="#common-traits-1">Common Traits</a></h2>
<ul>
<li><a href="https://dev.bonsaidb.io/main/bonsaidb/server/type.Server.html"><code>Server</code></a> implements <a href="integration/../traits/storage_connection.html"><code>StorageConnection</code></a>.</li>
<li><a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.CustomServer.html#method.database"><code>Server::database()</code></a> returns a local <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Database.html"><code>Database</code></a>, which implements <a href="integration/../traits/connection.html"><code>Connection</code></a>, <a href="integration/../traits/key-value.html"><code>KeyValue</code></a>, and <a href="integration/../traits/pubsub.html"><code>PubSub</code></a>. Local access in the server executable doesn't go over the network.</li>
<li><a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.Client.html"><code>Client</code></a> implements <a href="integration/../traits/storage_connection.html"><code>StorageConnection</code></a>.</li>
<li><a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.Client.html#method.database"><code>Client::database()</code></a> returns a <a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a>, which implements <a href="integration/../traits/connection.html"><code>Connection</code></a>, <a href="integration/../traits/key-value.html"><code>KeyValue</code></a>, and <a href="integration/../traits/pubsub.html"><code>PubSub</code></a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-into-a-bonsaidb-cluster"><a class="header" href="#integrating-into-a-bonsaidb-cluster">Integrating into a BonsaiDb Cluster</a></h1>
<p>Coming Soon.</p>
<p>The goals of this feature are to make clustering simple. We hope to provide an experience that allows someone who is operating a networked server to desire two types of clusters:</p>
<h2 id="one-leader-mode"><a class="header" href="#one-leader-mode">One-leader mode</a></h2>
<p>When setting up a cluster initially, you will begin with one-leader mode. In this mode, you can add as many nodes to the cluster as you wish, but only one node will be processing all of the data updates. All nodes can handle requests, but requests that can't be served locally will be forwarded to the leader. This allows for the use of read-replicas to alleviate load in some read-heavy situations.</p>
<p>Another benefit of this mode are that it supports a two-node configuration. If you're scaling your app and need a reliable backup for quicker disaster recovery, you can operate a read replica and manually failover when the situation arises.</p>
<p>If you decide to allow automatic failover in this mode, there is a chance for data loss, as the leader does not wait for read-replicas to synchronize data. Any transactions that committed and were not synchronized before the outage occurred would not be on the other servers. Thus, this mode is <em>not intended for high-availability configurations</em>, although some users may elect to use it in such a configuration knowing these limitations.</p>
<h2 id="quorum-mode"><a class="header" href="#quorum-mode">Quorum mode</a></h2>
<p>Once you have a cluster with at least 3 nodes, you can switch the cluster into quorum mode. For any given <code>N</code> nodes, all requests must reach an agreed response by <code>N / 2 + 1</code> members. For example, in a cluster of 3 nodes, there must be 2 successful responses before a client can receive a response to its request.</p>
<p>In quorum mode, your data is divided into shards and those shards replicated throughout the cluster onto at least 3 nodes (configurable). Initially, with just 3 nodes available, the only benefits are having a highly-available cluster with no data loss during when a single node goes down.</p>
<p>As you add more nodes to your cluster, however, you can re-balance your databases to move shards. The author of BonsaiDb did not enjoy this process in CouchDB when he had to do it and aims to make these tools easy and effortless to use. Ideally, there would be a low-maintenance mode that would allow the cluster to re-shard itself authomatically during allowed maintenance periods, ensuring data is distributed more evenly amongst the cluster.</p>
<p>Additional long-term dreams of quorum mode include the ability to customize node selection criteria on a per-database basis. The practical use of node selection is to ensure that at least 3 unique nodes are picked for each shard. However, allowing custom logic to evaluate which nodes should be selected for any database would allow ultimate flexibility. For example, if you have a globally deployed application, and you have some data that is geographically specific, you could locate each region's database on nodes within those locations' data centers.</p>
<h2 id="when"><a class="header" href="#when">When?</a></h2>
<p>Clustering is an important part of the design of <a href="https://github.com/khonsulabs/cosmicverge">Cosmic Verge</a>. As such, it is a priority for us to work on. But, the overall game is a very large project, so we hesitate to make any promises on timelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection"><a class="header" href="#connection">Connection</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/trait.Connection.html"><code>Connection</code> trait</a> contains functions for interacting with collections in a database. This trait is implemented by the <a href="traits/../about/concepts/database.html"><code>Database</code></a> types in each crate:</p>
<ul>
<li>For bonsaidb-local: <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Database.html"><code>Database</code></a></li>
<li>For bonsaidb-server: <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerDatabase.html"><code>ServerDatabase</code></a></li>
<li>For bonsaidb-client: <a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a></li>
</ul>
<p>Using this trait, you can write code that generically can work regardless of whether BonsaiDb is operationg locally with no network connection or across the globe.</p>
<p>This is an <a href="https://crates.io/crates/async-trait">async trait</a>, which unfortunately yields <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/trait.Connection.html">messy documentation</a> due to the lifetimes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storageconnection"><a class="header" href="#storageconnection">StorageConnection</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/trait.StorageConnection.html"><code>StorageConnection</code> trait</a> contains functions for interacting with BonsaiDb's multi-database storage. This trait is implemented by these types:</p>
<ul>
<li>For bonsaidb-local: <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Storage.html"><code>Storage</code></a></li>
<li>For bonsaidb-server: <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.CustomServer.html"><code>CustomServer&lt;Backend&gt;</code></a> / <a href="https://dev.bonsaidb.io/main/bonsaidb/server/type.Server.html"><code>Server</code></a></li>
<li>For bonsaidb-client: <a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.Client.html"><code>Client</code></a></li>
</ul>
<p>Using this trait, you can write code that generically can work regardless of whether BonsaiDb is operationg locally with no network connection or across the globe.</p>
<p>This is an <a href="https://crates.io/crates/async-trait">async trait</a>, which unfortunately yields <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/trait.StorageConnection.html">messy documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubsub-trait"><a class="header" href="#pubsub-trait">PubSub Trait</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/core/pubsub/trait.PubSub.html"><code>PubSub</code> trait</a> contains functions for using <a href="traits/../about/concepts/pubsub.html">PubSub</a> in BonsaiDb. This trait is implemented by the <a href="traits/../about/concepts/database.html"><code>Database</code></a> types in each crate:</p>
<ul>
<li>For bonsaidb-local: <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Database.html"><code>Database</code></a></li>
<li>For bonsaidb-server: <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerDatabase.html"><code>ServerDatabase</code></a></li>
<li>For bonsaidb-client: <a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a></li>
</ul>
<p>Using this trait, you can write code that generically can work regardless of whether BonsaiDb is operationg locally with no network connection or across the globe.</p>
<p>This is an <a href="https://crates.io/crates/async-trait">async trait</a>, which unfortunately yields <a href="https://dev.bonsaidb.io/main/bonsaidb/core/pubsub/trait.PubSub.html">messy documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-value-trait"><a class="header" href="#key-value-trait">Key-Value Trait</a></h1>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/core/keyvalue/trait.KeyValue.html"><code>KeyValue</code> trait</a> contains functions for interacting the atomic key-value store. The key-value store provides high-performance atomic operations without ACID compliance. Once the data is persisted to disk, it holds the same guarantees as all of BonsaiDb, but this feature is designed for high throughput and does not wait to persist to disk before reporting success to the client. This trait is implemented by the <a href="traits/../about/concepts/database.html"><code>Database</code></a> types in each crate:</p>
<ul>
<li>For bonsaidb-local: <a href="https://dev.bonsaidb.io/main/bonsaidb/local/struct.Database.html"><code>Database</code></a></li>
<li>For bonsaidb-server: <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerDatabase.html"><code>ServerDatabase</code></a></li>
<li>For bonsaidb-client: <a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a></li>
</ul>
<p>Using this trait, you can write code that generically can work regardless of whether BonsaiDb is operationg locally with no network connection or across the globe.</p>
<p>This is an <a href="https://crates.io/crates/async-trait">async trait</a>, which unfortunately yields <a href="https://dev.bonsaidb.io/main/bonsaidb/core/keyvalue/trait.KeyValue.html">messy documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>BonsaiDb attempts to have reasonable default configuration options, but it's important to browse the available options to ensure there aren't options that might help your particular needs.</p>
<h2 id="storage-configuration"><a class="header" href="#storage-configuration">Storage Configuration</a></h2>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/struct.StorageConfiguration.html"><code>StorageConfiguration</code></a> structure is used to open a local-only database. The <code>ServerConfiguration</code> struct contains <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#structfield.storage">an instance of <code>StorageConfiguration</code></a>, and all configuration optionsl are available on it.</p>
<h3 id="vault-key-storage"><a class="header" href="#vault-key-storage">Vault Key Storage</a></h3>
<p>By default, BonsaiDb sets <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/struct.StorageConfiguration.html#structfield.vault_key_storage"><code>vault_key_storage</code></a> to a file stored within the database folder. This is <strong>incredibly insecure and should not be used outside of testing</strong>.</p>
<p>For secure encryption, it is important to store the vault keys in a location that is separate from the database. If the keys are on the same harware as the database, anyone with access to the disk will be able to decrypt the stored data.</p>
<p>If you have more than one server, you can still use <a href="https://dev.bonsaidb.io/main/bonsaidb/local/vault/struct.LocalVaultKeyStorage.html"><code>LocalVaultKeyStorage</code></a> in conjunction with a mounted network share for reasonable security practices -- assuming the network share itself is properly secured.</p>
<p>If you have an S3-compatible storage service available, you can use <a href="https://dev.bonsaidb.io/main/bonsaidb/keystorage/s3/index.html"><code>bonsaidb::keystorage::s3</code></a> to store the vault keys with that service.</p>
<p>Note that by storing your keys remotely, your BonsaiDb database will not be able to be opened unless the keys are able to be read.</p>
<p>Vault Key Storage can also be set using <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/trait.Builder.html#tymethod.vault_key_storage"><code>Builder::vault_key_storage</code></a>.</p>
<h3 id="default-encryption-key"><a class="header" href="#default-encryption-key">Default Encryption Key</a></h3>
<p>By setting <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/struct.StorageConfiguration.html#structfield.default_encryption_key"><code>default_encryption_key</code></a> to a key, all data will be encrypted when written to the disk.</p>
<p>If <code>default_encryption_key</code> is <code>None</code>, encryption will still be performed for collections that return a key from <a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.Collection.html#method.encryption_key"><code>Collection::encryption_key()</code></a>.</p>
<p>Can also be set using <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/trait.Builder.html#tymethod.default_encryption_key"><code>Builder::default_encryption_key</code></a>.</p>
<h3 id="tasks-worker-count"><a class="header" href="#tasks-worker-count">Tasks: Worker Count</a></h3>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/struct.Tasks.html#structfield.worker_count"><code>tasks.worker_count</code></a> setting controls the number of worker tasks that are spawned to process background tasks.</p>
<p>Can also be set using <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/trait.Builder.html#tymethod.tasks_worker_count"><code>Builder::tasks_worker_count</code></a>.</p>
<h3 id="views-check-integrity-on-open"><a class="header" href="#views-check-integrity-on-open">Views: Check Integrity on Open</a></h3>
<p>When <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/struct.Views.html#structfield.check_integrity_on_open"><code>views.check_integrity_on_open</code></a> is true, all views in all databases will be checked on startup for integrity. If this value is false, the integrity of the view will not be checked until it is accessed for the first time.</p>
<p>By default, BonsaiDb delays checking a view's integrity until its accessed for the first time. it may, however, be preferred to have a higher startup time to ensure consistent response times once the server is running after a restart of the server.</p>
<p>Can also be set using <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/trait.Builder.html#tymethod.check_view_integrity_on_open"><code>Builder::check_view_integrity_on_open</code></a>.</p>
<h3 id="key-value-persistence"><a class="header" href="#key-value-persistence">Key-Value Persistence</a></h3>
<p>The Key-Value store is designed to be a lightweight, atomic data store that is suitable for caching data, tracking metrics, or other situations where a Collection might be overkill.</p>
<p>By default, BonsaiDb persists Key-Value store changes to disk immediately. For light usage, this will not be noticable, and it ensures that no data will ever be lost.</p>
<p>If you're willing to accept potentially losing recent writes, <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/trait.Builder.html#tymethod.key_value_persistence"><code>key_value_persistence</code></a> can be configured to lazily commit changes to disk. The documentation for <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/struct.KeyValuePersistence.html"><code>KeyValuePersistence</code></a> contains examples as well as an explanation of how the rules are evaluated.</p>
<p>Key-Value Persistence can also be set using <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/trait.Builder.html#tymethod.key_value_persistence"><code>Builder::key_value_persistence</code></a>.</p>
<h2 id="server-configuration"><a class="header" href="#server-configuration">Server Configuration</a></h2>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html"><code>ServerConfiguration</code></a> structure is used to open a BonsaiDb server. Being built atop the local storage engine, this structure exposes <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#structfield.storage">an instance of <code>StorageConfiguration</code></a>, allowing full customization.</p>
<h3 id="server-name"><a class="header" href="#server-name">Server Name</a></h3>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#structfield.server_name"><code>server_name</code></a> setting is for the primary DNS name of the server. The server's TLS certificate should be valid for the server's name.</p>
<p>When using ACME, this setting controls the primary certificate requested.</p>
<p>Can also be set using <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#method.server_name">a builder-style method</a>.</p>
<h3 id="client-simultaneous-request-limit"><a class="header" href="#client-simultaneous-request-limit">Client Simultaneous Request Limit</a></h3>
<p>BonsaiDb's networking protocols support multiple requests to be sent before any responses have been received, sometimes called pipelining. Without a limit, a single malicious client could send a large number of load-inducing requests and cause reliability of service issues for other clients.</p>
<p>By limiting each connection's maximum ability to a reasonable number, it allows clients to take advantage of pipelining without allowing any one client to saturate the server with requests.</p>
<p>This limit is set using the <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#structfield.client_simultaneous_request_limit">client_simultaneous_request_limit</a> field or <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#method.client_simultaneous_request_limit">builder-style method</a>.</p>
<h3 id="request-worker-count"><a class="header" href="#request-worker-count">Request Worker Count</a></h3>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#structfield.request_workers"><code>request_workers</code></a> configuration controls the number of worker tasks that process incoming requests from connected clients. It can also be set via a <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#method.request_workers">builder-style method</a>.</p>
<h3 id="default-permissions-and-authenticated-permissions"><a class="header" href="#default-permissions-and-authenticated-permissions">Default Permissions and Authenticated Permissions</a></h3>
<p>When first connecting to a server, the client is unauthenticated and is granted the permissions defined by <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#structfield.default_permissions"><code>default_permissions</code></a>. Once a connected client has authenticated, the client will be granted <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#structfield.authenticated_permissions"><code>authenticated_permissions</code></a> in addition to whatever permissions already granted by the authenticated role.</p>
<p>By default, both <code>default_permissions</code> and <code>authenticated_permissions</code> contain no granted permissions. This means that by default, no connections are allowed to a server, as the connection hasn't been gramted <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/enum.BonsaiAction.html#variant.Server"><code>BonsaiAction::Server(</code></a><a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/enum.ServerAction.html#variant.Connect"><code>ServerAction::Connect() )</code></a>.</p>
<h3 id="acme-configuration-letsencrypt"><a class="header" href="#acme-configuration-letsencrypt">ACME Configuration (LetsEncrypt)</a></h3>
<p>ACME has two configurable options, a contact email and the ACME directory.</p>
<h4 id="acme-contact-email"><a class="header" href="#acme-contact-email">ACME Contact Email</a></h4>
<p>The contact email is submitted to the ACME directory as part of requesting a TLS certificate. It is optional for the LetsEncrypt directories.</p>
<p>A valid value for this field begins with <code>mailto:</code>.</p>
<p>The contact email can be set using <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.AcmeConfiguration.html#structfield.contact_email"><code>acme.contact_email</code></a> or the <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#method.acme_contact_email">builder-style method</a>.</p>
<h4 id="acme-directory"><a class="header" href="#acme-directory">ACME Directory</a></h4>
<p>By default, BonsaiDb uses the <a href="https://dev.bonsaidb.io/main/bonsaidb/server/constant.LETS_ENCRYPT_PRODUCTION_DIRECTORY.html">production LetsEncrypt directory</a>, but any ACME directory can be specified.</p>
<p>The directory can be set using <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.AcmeConfiguration.html#structfield.directory"><code>acme.directory</code></a> or the <a href="https://dev.bonsaidb.io/main/bonsaidb/server/struct.ServerConfiguration.html#method.acme_directory">builder-style method</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="permissions-1"><a class="header" href="#permissions-1">Permissions</a></h1>
<p><code>BonsaiDb</code> uses <a href="https://en.wikipedia.org/wiki/Role-based_access_control">role-based access control (RBAC)</a>. In short, permissions are granted through statements within permission groups. Users are able to <a href="https://dev.bonsaidb.io/main/bonsaidb/client/struct.Client.html#method.login_with_password_str">log in</a> and receive permissions that were granted via permission groups or roles.</p>
<p>This section has two subsections:</p>
<ul>
<li><a href="administration/./permission-statements.html">Permission Statements</a>: An overview of the resource names and actions used within <code>BonsaiDb</code>.</li>
<li><a href="administration/./rbac.html">Users, Groups, and Roles</a>: A more thorough explanation of <code>BonsaiDb</code>'s access control.</li>
</ul>
<p>While the most common use case will be granting permissions to act upon <code>BonsaiDb</code> itself, the permissions system is designed to be generic enough that it can be used as the application's permission system if desired.</p>
<p>By default, no actions are allowed.</p>
<p>Currently, permissions are only applied to connections over a network. In <a href="https://github.com/khonsulabs/bonsaidb/issues/68">the future</a>, permissions will be able to be applied even on local connections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="permission-statements"><a class="header" href="#permission-statements">Permission Statements</a></h1>
<p>A <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/struct.Statement.html">Statement</a> grants permissions to execute <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/trait.Action.html"><code>Action</code>s</a> on <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/struct.ResourceName.html"><code>ResourceName</code>s</a>.</p>
<h2 id="actions-and-resources"><a class="header" href="#actions-and-resources">Actions and Resources</a></h2>
<p><code>ResourceName</code>s are simply namespaced <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/enum.Identifier.html"><code>Identifier</code>s</a>. An example could be: <code>&quot;bonsaidb&quot;.*.&quot;khonsulabs-admin.users&quot;.1</code>. Each segment can be <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/enum.Identifier.html#variant.String">a string</a>, <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/enum.Identifier.html#variant.Integer">an integer</a>, or <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/enum.Identifier.html#variant.Any">a wildcard (<code>*</code>)</a>.</p>
<p>In <code>BonsaiDb</code>, nearly everything has a resource name. The example above refers to a document with ID <code>1</code> in the <code>khonsulabs-admin.users</code> collection in any database. The <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/index.html"><code>bonsaidb::core::permissions::bonsai</code></a> module contains functions to create properly formatted <code>ResourceName</code>s.</p>
<p>Also within the same module are the built-in <code>Action</code>s. The base enum for all actions used within <code>BonsaiDb</code> is <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/enum.BonsaiAction.html"><code>BonsaiAction</code></a> Below is an overview of the resource names and actions by category.</p>
<h3 id="server"><a class="header" href="#server">Server</a></h3>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/enum.ServerAction.html"><code>ServerAction</code></a> enum contains the actions that are related to <a href="https://dev.bonsaidb.io/main/bonsaidb/core/connection/trait.StorageConnection.html"><code>StorageConnection</code></a>. For APIs that accept a database name parameter, the resource name will be <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/fn.database_resource_name.html"><code>database_resource_name(database)</code></a>. For all other actions, the resource name is <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/fn.bonsaidb_resource_name.html"><code>bonsaidb_resource_name()</code></a>.</p>
<p>For actions that operate upon users (e.g., creating a user), the resource name is <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/fn.user_resource_name.html">user_resource_name(username)</a>.</p>
<h4 id="at-rest-encryption"><a class="header" href="#at-rest-encryption">At-rest Encryption</a></h4>
<p>Access to encrypted information can be controlled by limiting access to the encryption key used. Currently, <code>BonsaiDb</code> only has support for a shared master key, but in the future additional keys will be able to be created. Because <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/enum.EncryptionKeyAction.html#variant.Encrypt"><code>Encrypt</code></a> and <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/enum.EncryptionKeyAction.html#variant.Decrypt"><code>Decrypt</code></a> are separate actions, access to read and write can be controlled independently.</p>
<p>The resource name for an encryption key is <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/fn.encryption_key_resource_name.html"><code>encryption_key_resource_name(key_id)</code></a>.</p>
<h3 id="database-1"><a class="header" href="#database-1">Database</a></h3>
<p>The <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/enum.DatabaseAction.html"><code>DatabaseAction</code></a> enum contains the actions that are related to a specific database. Actions that act on the database directly will use the resource name <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/fn.database_resource_name.html"><code>database_resource_name(database)</code></a>.</p>
<p>For <code>Collection</code>s, there are three resource names used. For actions that operate on the collection directly, the resource name is <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/fn.database_resource_name.html"><code>collection_resource_name(database, collection)</code></a>. For actions that operate on a document, the resource name is <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/fn.document_resource_name.html"><code>document_resource_name(database, collection, id)</code></a>. Finally, for actions that operate on a <code>View</code>, the resource name is <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/fn.view_resource_name.html"><code>view_resource_name(database, view)</code></a>.</p>
<p>For actions that operate upon the key-value entry, the resource name is <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/fn.keyvalue_key_resource_name.html"><code>keyvalue_key_resource_name(database, namespace, key)</code></a>.</p>
<p>For actions that operate on a <code>PubSub</code> topic, the resource name is <a href="https://dev.bonsaidb.io/main/bonsaidb/core/permissions/bonsai/fn.pubsub_topic_resource_name.html"><code>pubsub_topic_resource_name(database, topic)</code></a>.</p>
<h2 id="statement-examples"><a class="header" href="#statement-examples">Statement Examples</a></h2>
<p><em>Coming Soon</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="users-groups-and-roles"><a class="header" href="#users-groups-and-roles">Users, Groups, and Roles</a></h1>
<p>The most common flow that a database administrator needs to support is granting a user the ability to take specific actions on specific resources. To accomplish this, a <a href="https://dev.bonsaidb.io/main/bonsaidb/core/admin/struct.PermissionGroup.html"><code>PermissionGroup</code></a> must be created containing the permission statements, covered in <a href="administration/./permission-statements.html">the previous section</a>, that you wish to apply.</p>
<p><code>PermissionGroup</code>s can be assigned directly to users by adding the group ID to their <a href="https://dev.bonsaidb.io/main/bonsaidb/core/admin/struct.User.html"><code>User</code> document</a>.</p>
<p>At first glance, <a href="https://dev.bonsaidb.io/main/bonsaidb/core/admin/struct.Role.html"><code>Role</code>s</a> may appear somewhat redundant. One or more <code>PermissionGroup</code>s can be assigned to a role, and roles can be assigned to a user. Why would you want to use roles at all?</p>
<p>The general advice the authors of <code>BonsaiDb</code> suggest is to use groups for limited amounts of functionality, keeping each group's list of statements concise and easy to understand. Then, create roles that combine groups of functionality in meaningful ways. One meaningful way could be creating roles based on job titles inside of a company. In theory, a person's job defines what they do within the company.</p>
<p>In practice, permissions are never as clean as one would hope, which is why <code>BonsaiDb</code> allows assigning groups and roles to users directly. Roles should be used as much as possible, but sometimes assigning a group directly is just needed. For example, imagine the CEO telling you, &quot;I know Bob is just a sales guy, but he needs to be able to update this record. I trust him more than the other sales people. Just make it happen.&quot; As the database administrator, you can decide whether to introduce a new role or just temporarily assign an extra group to this one user.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="at-rest-encryption-1"><a class="header" href="#at-rest-encryption-1">At-Rest Encryption</a></h1>
<p><code>BonsaiDb</code> offers at-rest encryption. An overview of how it works is available <a href="https://dev.bonsaidb.io/main/bonsaidb/local/vault/index.html">in the <code>bonsaidb::local::vault</code> module</a>.</p>
<h2 id="enabling-at-rest-encryption-by-default"><a class="header" href="#enabling-at-rest-encryption-by-default">Enabling at-rest encryption by default</a></h2>
<p>When opening your <code>BonsaiDb</code> instance, there is a configuration option <a href="https://dev.bonsaidb.io/main/bonsaidb/local/config/struct.StorageConfiguration.html#structfield.default_encryption_key"><code>default_encryption_key</code></a>. Once this is set, all new data written that supports being encrypted will be encrypted at-rest.</p>
<pre><code class="language-rust noplayground no_run">let storage = Storage::open(
    StorageConfiguration::new(&amp;directory)
        .vault_key_storage(vault_key_storage)
        .default_encryption_key(KeyId::Master)
)
.await?;
</code></pre>
<h2 id="enabling-at-rest-encryption-on-a-per-collection-basis"><a class="header" href="#enabling-at-rest-encryption-on-a-per-collection-basis">Enabling at-rest encryption on a per-collection basis</a></h2>
<p><a href="https://dev.bonsaidb.io/main/bonsaidb/core/schema/trait.Collection.html#method.encryption_key"><code>Collection::encryption_key()</code></a> can be overridden on a per-Collection basis. If a collection requests encryption but the feature is disabled, an error will be generated.</p>
<p>To enable a collection to be encrypted when the feature is enabled, only return a key when <a href="https://dev.bonsaidb.io/main/bonsaidb/core/constant.ENCRYPTION_ENABLED.html">ENCRYPTION_ENABLED</a> is true.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
